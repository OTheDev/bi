<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>bi: Algorithms</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">bi
   </div>
   <div id="projectbrief">An arbitrary precision integer library for C++.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">Algorithms</div></div>
</div><!--header-->
<div class="contents">


<h3><a id="add" name="add"></a>Addition/Subtraction</h3><div class="textblock"><p>Knuth Algorithm A (Vol. 2, 4.3.1, p. 266) </p><hr  />
<p> <b>Input</b>:  </p><p class="formulaDsp">
\[
  (u_{n-1} \cdots u_{0})_{b}, (v_{n-1} \cdots v_{0})_{b} \geq 0
\]
</p>
<p><b>Output</b>: radix-b sum  </p><p class="formulaDsp">
\[
  (w_{n} \cdots w_{0})_{b}, \; w_{n} \in \{0, 1\}
\]
</p>
<ol type="1">
<li>Set \( j \leftarrow 0, \; k \leftarrow 0 \).</li>
<li>Set  <p class="formulaDsp">
\begin{align}
  t     &amp;\leftarrow u_{j} + v_{j} + k                                     \\
  w_{j} &amp;\leftarrow t \bmod b                                             \\
  k     &amp;\leftarrow \left\lfloor \frac{t}{b} \right\rfloor
    \Longleftrightarrow k \leftarrow t \geq b
\end{align}
</p>
</li>
<li>Increase \( j \) by one. If \( j &lt; n \), go to (2); else, set \(
w_{n} \leftarrow k \) and terminate.</li>
</ol>
<p>The use of the temporary \( t \) in (2) permits the same storage locations for both input and output (Exercise 30, p. 283). <em>This applies for algorithm S as well</em>.</p>
<p>Knuth Algorithm S (Vol. 2, 4.3.1, p. 267) </p><hr  />
<p> <b>Input</b>:  </p><p class="formulaDsp">
\[
  (u_{n-1} \cdots u_{0})_{b} \geq (v_{n-1} \cdots v_{0})_{b} \geq 0
\]
</p>
<p><b>Output</b>: radix-b difference  </p><p class="formulaDsp">
\[
  (w_{n-1} \cdots w_{0})_{b}
\]
</p>
<ol type="1">
<li>Set \( j \leftarrow 0, \; k \leftarrow 0 \).</li>
<li>Set  <p class="formulaDsp">
\begin{align}
  t     &amp;\leftarrow u_{j} - v_{j} + k                                     \\
  w_{j} &amp;\leftarrow t \bmod b                                             \\
  k     &amp;\leftarrow \left\lfloor \frac{t}{b} \right\rfloor
\end{align}
</p>
</li>
<li>Increase \( j \) by one. If \( j &lt; n \), go to (2); else, terminate. </li>
</ol>
</div>

<h3><a id="mul" name="mul"></a>Multiplication</h3><div class="textblock"><p>Knuth Algorithm M (Vol. 2, 4.3.1, pp. 268-269) </p><hr  />
<p> <b>Input</b>: \( (u_{m-1} \ldots u_{0})_{b},
               (v_{n-1} \ldots v_{0})_{b} \geq 0 \)</p>
<p><b>Output</b>: radix-b product \( (w_{m+n-1} \ldots w_{0})_{b} \)</p>
<ol type="1">
<li>Set \( w_{m-1}, \ldots , w_{0} \) to 0. Set \( j \leftarrow 0 \).</li>
<li>Set \( i \leftarrow 0, k \leftarrow 0 \).</li>
<li>Set (in order from top to bottom)  <p class="formulaDsp">
\begin{align}
  t         &amp;\leftarrow u_{i} \times v_{j} + w_{i + j} + k                \\
  w_{i + j} &amp;\leftarrow t \bmod b                                         \\
  k         &amp;\leftarrow \left\lfloor \frac{t}{b} \right\rfloor
\end{align}
</p>
</li>
<li>Increase \( i \) by one. If \( i &lt; m \), go to (3); else, set \(
w_{j + m} \leftarrow k \).</li>
<li>Increase \( j \) by one. If \( j &lt; n \), go to (2); else, terminate.</li>
</ol>
<p>Algorithm permits \( v_{j} \) to be in the same memory location as \( w_{j + n} \) (Exercise 30, p. 627) but, in general, special handling is needed for overlapping memory (e.g. through the use of temporaries). </p>
</div>

<h3><a id="mul_square" name="mul_square"></a>Multiplication - Multiple-Precision Squaring</h3><div class="textblock"><p>Knuth Algorithm M can be used generally for multiplying two arbitrary precision integers. However, if the two operands are equal, there are algorithms that can improve the efficiency by about a factor of two. For multiple-precision squaring, we follow <b>Algorithm 14.16</b> from the <b>Handbook of Applied Cryptography</b> by A. Menezes, P. van Oorschot, and S. Vanstone (pp. 596-597). </p>
</div>

<h3><a id="mul_karatsuba" name="mul_karatsuba"></a>Multiplication - Karatsuba</h3><div class="textblock"><p>When both operands of multiplication require many base \( b \) digits, we can make use of the following observation to implement a recursive algorithm that is more efficient than the standard quadratic pencil-and-paper method.</p>
<p>The following is adapted from Knuth Vol. 2, pp. 294-295.</p>
<p>Consider two integers with \( 2n \) base-b digits and their product:  </p><p class="formulaDsp">
\begin{align}
  u &amp;= (u_{2n-1} \cdots u_{0})_{b} = b^{n}U_{1} + U_{0} \\
  v &amp;= (v_{2n-1} \cdots v_{0})_{b} = b^{n}V_{1} + V_{0} \\
  U_{1} &amp;\equiv (u_{2n-1} \cdots u_{n})_{b},
    \; U_{0} \equiv (u_{n-1} \cdots u_{0})_{b} \\
  V_{1} &amp;\equiv (v_{2n-1} \cdots v_{n})_{b},
    \; V_{0} \equiv (v_{n-1} \cdots v_{0})_{b} \\
  uv  &amp;= (b^{n}U_{1} + U_{0})(b^{n}V_{1} + V_{0})
\end{align}
</p>
<p> It is simple to verify that the product is equivalent to  </p><p class="formulaDsp">
\[
  uv = b^{2n}U_{1}V_{1} + b^{n}\left[(U_{1}+U_{0})(V_{1}+V_{0}) -
    (U_{0}V_{0} + U_{1}V_{1})\right] + U_{0}V_{0}
\]
</p>
<p> The result of multiplying two \( 2n \) digit integers can be found via three multiplications of \( n \) digit integers (plus cheaper bit shifts and additions). </p>
</div>

<h3><a id="div" name="div"></a>Division by single-precision integer</h3><div class="textblock"><p>Knuth Exercise 16 (Vol. 2, 4.3.1, p. 282) </p><hr  />
<p> <b>Input</b>: \( u = (u_{n-1} \ldots u_{0})_{b} \geq 0 \; \text{and} \;
               v \in (0, b-1] \)</p>
<p><b>Output</b>: radix-b  </p><p class="formulaDsp">
\begin{align}
  \text{quotient}&amp;:
    \left\lfloor \frac{u}{v} \right\rfloor = (w_{n-1} \cdots w_{0})_{b}   \\
  \text{remainder}&amp;: u \bmod v = r
\end{align}
</p>
<ol type="1">
<li>Set \( r \leftarrow 0, \; j \leftarrow n - 1 \).</li>
<li>Set  <p class="formulaDsp">
\begin{align}
  w_{j} &amp;\leftarrow \left\lfloor \frac{(rb + u_{j})}{v} \right\rfloor     \\
  r     &amp;\leftarrow (rb + u_{j}) \bmod v
\end{align}
</p>
</li>
<li>Decrease \( j \) by 1. If \( j \geq 0 \), go to (2); else, terminate. </li>
</ol>
</div>

<h3><a id="division" name="division"></a>Division - Binary Long Division</h3><div class="textblock"><p>Let \( n \) denote the number of bits in numerator \( u \). Let \(
X(i) \) denote the \( ith \) bit of X (zero-based indexing; zero gives the LSB). This algorithm assumes that \( u \geq 0, \; v &gt; 0 \).</p>
<ol type="1">
<li>Set \( q \leftarrow 0, \; r \leftarrow 0 \).</li>
<li>Set \( i \leftarrow n - 1 \).</li>
<li>Set \( r \leftarrow r &lt;&lt; 1 \).</li>
<li>Set \( r(0) \leftarrow u(i) \).</li>
<li>If \( r \geq v \), set  <p class="formulaDsp">
\begin{align}
  r    &amp;\leftarrow r - v                                                  \\
  q(i) &amp;\leftarrow 1
\end{align}
</p>
</li>
<li>Decrease \( i \) by one. If \( i \geq 0 \), go to (3); else, terminate. </li>
</ol>
</div>

<h3><a id="knuth_d" name="knuth_d"></a>Division - Knuth Algorithm D</h3><div class="textblock"><p>Knuth Algorithm D (Vol. 2, 4.3.1, pp. 272-273) with Execise 37 (p. 283). </p><hr  />
<p> <b>Input</b>: \( u = (u_{m+n-1} \cdots u_{0})_{b},
               v = (v_{n-1} \cdots v_{0})_{b} \geq 0, \;
               v_{n-1} \neq 0, \; n &gt; 1 \)</p>
<p><b>Output</b>: radix-b  </p><p class="formulaDsp">
\begin{align}
  \text{quotient}&amp;:
    \left\lfloor \frac{u}{v} \right\rfloor = (q_{m} \cdots q_{0})_{b}     \\
  \text{remainder}&amp;: u \bmod v = (r_{n-1} \cdots r_{0})_{b}
\end{align}
</p>
<ol type="1">
<li>Normalize. Assuming \( b \) is a power of 2, set \( d \leftarrow 2^{e}
\) such that \( b &gt; 2^{e} \times v_{n-1} \geq \frac{b}{2} \). Then set  <p class="formulaDsp">
\begin{align}
  (u_{m+n} \cdots u_{0})_{b} &amp;\text{ to } (u_{m+n-1} \cdots u_{0})_{b}
    \times d                                                              \\
  (v_{n-1} \cdots v_{0})_{b} &amp;\text{ to } (v_{n-1} \cdots v_{0})_{b}
    \times d
\end{align}
</p>
 This can be achieved through bit shifting.</li>
<li>Set \( j \leftarrow m \).</li>
<li>Set  <p class="formulaDsp">
\begin{align}
  \hat{q} &amp;\leftarrow \left\lfloor \frac{u_{j+n}b + u_{j+n-1}}{v_{n-1}}
    \right\rfloor                                                         \\
  \hat{r} &amp;\leftarrow (u_{j+n}b + u_{j+n-1}) \bmod v_{n-1}
\end{align}
</p>
 Now, if \( \hat{q} = b \) or \( \hat{q}v_{n-2} &gt; b\hat{r} + u_{j+n-2}
\), then decrease \( \hat{q} \) by 1, increase \( \hat{r} \) by \(
v_{n-1} \) and repeat this test if \( \hat{r} &lt; b \).</li>
<li>Replace \( (u_{j+n} \cdots u_{j})_{b} \) by  <p class="formulaDsp">
\[
  (u_{j+n} \cdots u_{j})_{b} - \hat{q}(v_{n-1} \cdots v_{0})_{b}
\]
</p>
 The digits \( (u_{j+n},\ldots,u_{j}) \) should be kept positive. If the result of this step is actually negative, \( (u_{j+n} \cdots u_{j})_{b} \) should be left as the true value plus \( b^{n+1} \), namely, as the \( b
\)'s complement of the true value and a borrow to the left should be remembered.</li>
<li>Set \( q_{j} \leftarrow \hat{q} \). If the result of (4) was negative, go to (6); otherwise, go to (7).</li>
<li>Decrease \( q_{j} \) by 1 and add \( (0v_{n-1} \cdots v_{0})_{b} \) to \( (u_{j+n} \cdots u_{j})_{b} \). A carry will occur to the left of \( u_{j+n} \) and it should be ignored.</li>
<li>Decrease \( j \) by one. Then, if \( j \geq 0 \), go to (3).</li>
<li>\( (q_{m} \cdots q_{0})_{b} \) is the quotient and the remainder is the result of \( (u_{n-1} \cdots u_{0})_{b} \) divided by \( d \). </li>
</ol>
</div>

<h3><a id="string_to_integer" name="string_to_integer"></a>String to Integer</h3><div class="textblock"><p>String to integer conversion algorithms (e.g. used by <code>std::strtoul</code>, <code>std::from_chars</code>, and company) tend to follow a similar structure.</p>
<p>In the C/C++ Standards, many string to integer conversion functions have an integer <code>base</code> argument, accepting a base in \( [2, 36] \). The expected string of characters consists of digits and/or letters, together, representing the integer in the provided base. When processing the string of digits, characters '0' to '9' are mapped to the integer values 0 to 9, and the 26 letters in the alphabet, <code>a</code> (or <code>A</code>) to <code>z</code> (or <code>Z</code>), are mapped to the values 10 to 35:</p>
<p class="formulaDsp">
\begin{align}
  a &amp; \mapsto 10   \\
  b &amp; \mapsto 11   \\
    &amp; ...     \\
  z &amp; \mapsto 35
\end{align}
</p>
<p>Suppose we have a string of \( m \) characters, \( (ch_{m-1}, \ldots,
ch_{0}) \), where each character represents a digit in some base \( b \in
[2, 36] \). (Since \( b &gt; 1 \), there exists unique coefficients \(
a_{m-1}, \ldots, a_{0} \) such that the integer is equal to \( a_{m-1}
\cdot b^{m-1} + \cdots + a_{0} \cdot b^{0}) \). The resulting integer can be represented as:</p>
<p class="formulaDsp">
\[
  (a_{m-1} \cdots a_{0})_{b} = a_{m-1} \cdot b^{m-1} + \cdots + a_{0} \cdot
                               b^{0}
\]
</p>
<ol type="1">
<li><b>Set result to 0</b>. \( \text{result} = 0 \)</li>
<li><p class="startli"><b>Iterate over the characters</b>. For each character in \( (ch_{m-1},
\ldots, ch_{0}) \):</p>
<p class="startli">(a) <b>Convert the character to the base b digit it represents</b>. Call this value \( a_{j} \), where \( a_{j} \in \{0, 1, ..., b - 1\} \). \(
  a_{j} \) is the "current digit".</p>
<p class="startli">(b) <b>Multiply and add</b>.  </p><p class="formulaDsp">
\[
      \text{result} = \text{result} \cdot b + a_{j}
  \]
</p>
</li>
</ol>
<p>Writing out the value of the result at the end of each iteration:</p>
<p class="formulaDsp">
\begin{align}
  k = 0&amp;:
    \text{result} = a_{m - 1}                                             \\
  k = 1&amp;:
    \text{result} = a_{m - 1} \cdot b + a_{m-2}                           \\
  k = 2&amp;:
    \text{result} = a_{m - 1} \cdot b^{2} + a_{m - 2} \cdot b + a_{m - 3} \\
  &amp;\ldots                                                                 \\
  k = m - 1&amp;:
    \text{result} = a_{m - 1} \cdot b^{m - 1} + \cdots + a_{0} \cdot b^{0}
\end{align}
</p>
<p>It's clear we would be able to prove by induction that this holds generally.</p>
<dl class="section note"><dt>Note</dt><dd>Step (2)(a). Characters \( ch_{j} \) in the range ['0', '9'] have values  <p class="formulaDsp">
\[
  a_{j} = ch_{j} - \text{&#39;0&#39;}
\]
</p>
 The fact that characters corresponding to decimal digits have consecutive integer values is guaranteed by the C/C++ standards. In most systems, lowercase and uppercase letters also have consecutive integer values, but this is not guaranteed by the standards. In systems that do make their values consecutive, we can use the relationships below. However, for maximizing portability, this implementation <em>does not</em> assume that their values are consecutive. <br  />
<br  />
 Characters in the range ['a', 'z'] have values  <p class="formulaDsp">
\[
  a_{j} = ch_{j} - \text{&#39;a&#39;} + 10
\]
</p>
 Character in the range ['A', 'Z'] have values  <p class="formulaDsp">
\[
  a_{j} = ch_{j} - \text{&#39;A&#39;} + 10
\]
</p>
</dd></dl>
<p>Once we start dealing with many very large strings, analysis and benchmarks show that we can do a lot better by processing the string of alphanumerics in batches.</p>
<p>Let \( e \) denote the exponent corresponding to the highest power of base \( b \in [2, 36] \) that fits in a base \( \text{bi_base} &gt; b \) digit [<a class="el" href="#e_example">1</a>]. By definition, any \( e \)-digit base-b integer</p>
<p class="formulaDsp">
\[
  \phi_{e - 1}\cdot b^{e - 1} + \cdots + \phi_{0} \cdot b^{0}
\]
</p>
<p>can be represented by a single base-<code>bi_base</code> digit. The exponent \( e \) can be referred to as the <b>maximum batch size</b> (i.e. the maximum number of characters in a batch).</p>
<ol type="1">
<li><b>Set result to 0</b>. \( \text{result} = 0 \).</li>
<li><b>Set k to 0</b>. \( k = 0 \). Define \( k \) as a zero-based index for the characters in a string of \( m \) alphanumerics. Valid indices are in the set \( [0, m - 1] \).</li>
<li><p class="startli"><b>Iterate over the characters</b>.</p>
<p class="startli">(a) If \( k \) is equal to \( m \), <b>return</b> \( \text{result} \).</p>
<p class="startli">(b) <b>Set batch value to 0</b>. \( \text{batch_value} = 0 \).</p>
<p class="startli">(c) <b>Calculate how many characters to batch</b>: \( \lambda \). This should be the minimum of \( e \) and the number of characters remaining in the string that have not yet been processed.  </p><p class="formulaDsp">
\[
    \lambda \equiv \min \{e, \; m - k\}
  \]
</p>
<p class="startli">(d) <b>Calculate the batch value</b>. Use the algorithm specified above. That is, for each \( j \in (0, 1, \ldots, \lambda - 1) \), obtain the base-b digit that the current character maps to (call this \( \text{cur_digit}
  \)), calculate  </p><p class="formulaDsp">
\[
    \text{batch_value} = \text{batch_value} * b + \text{cur_digit}
  \]
</p>
<p class="startli">and then increase \( k \) by 1.</p>
<p class="startli">At the end of this loop, the batch value represents a \( \lambda \) digit base-b integer or a single base \( b^{\lambda} \) digit.</p>
<p class="startli">(e) <b>Multiply and add</b>.  </p><p class="formulaDsp">
\[
    \text{result} = \text{result} \cdot b^{\lambda} + \text{batch_value}
  \]
</p>
</li>
</ol>
<p>To see that this works, it helps to write out a few iterations.</p>
<p>If \( m \leq e \), \( \text{result} = \text{batch_value} \) and we are done.</p>
<p>If \( m \gt e \), there's at least one full batch and some residual. Let's consider this case.</p>
<p>After processing the <b>first substring</b>:</p>
<p class="formulaDsp">
\begin{align}
\text{result}
  &amp;= 0 \cdot b^{e} + (a_{m-1}b^{e-1} + \cdots + a_{m-e}b^{0})             \\
  &amp;= a_{m-1}b^{e-1} + \cdots + a_{m-e}b^{0}
\end{align}
</p>
<p>Suppose \( m - k \ge e\), so that we have another full batch. The result after processing the <b>second substring</b> is:</p>
<p class="formulaDsp">
\begin{align}
\text{result}
  &amp;= (a_{m-1}b^{e-1} + \cdots + a_{m-e}b^{0}) \cdot b^{e} +
     (a_{m-e-1}b^{e-1} + \cdots + a_{m-2e}b^{0})                          \\
  &amp;= a_{m-1}b^{2e-1} + \cdots + a_{m-e}b^{e} + \cdots + a_{m-2e}b^{0}
\end{align}
</p>
<p>Suppose \( m - k \ge e\) a total of \( \Omega \) times. After processing the \( \Omega\text{th} \) <b>substring</b>:</p>
<p class="formulaDsp">
\begin{align}
\text{result}
  &amp;= a_{m-1}b^{\Omega e - 1} + \cdots + a_{m-\Omega e}b^{0}
\end{align}
</p>
<p>Suppose \( l \equiv m - k &lt; e \). This will be the last substring. After processing the last substring:</p>
<p class="formulaDsp">
\begin{align}
\text{result}
  &amp;= (a_{m-1}b^{\Omega e-1} + \cdots + a_{m-\Omega e}b^{0})\cdot b^{l} +
     (a_{m - \Omega e - 1}b^{l-1} + \cdots + a_{0}b^{0})                  \\
  &amp;= a_{m-1}b^{(\Omega e +l)-1} + \cdots + a_{0}b^{0}                     \\
  &amp;= a_{m-1}b^{m-1} + \cdots + a_{0}b^{0}
\end{align}
</p>
<p>Above, \( \Omega e + l \) is none other than the number of characters in the string of alphanumerics, which, by definition, is \( m \).</p>
<p><a class="anchor" id="e_example"></a>1. For example, if \( \text{bi_base} = 2^{64} \), the highest power of 10 that fits in a base-<code>bi_base</code> digit is \( 10^{19} \). \( e \) is then 19. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0
</small></address>
</body>
</html>
